<!DOCTYPE html>
<html lang="ja">
<head>
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;500&family=Playfair+Display:wght@400;600&display=swap" rel="stylesheet">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>The Reading Journal</title>

  <style>
    body {
      font-family: 'Cormorant Garamond', serif;
      background: #f7f3ed;
      margin: 0;
      padding: 90px;
      color: #2b2b2b;
      font-size: 18px;
      line-height: 1.6;
    }

    h1 {
      font-family: 'Playfair Display', serif;
      text-align: center;
      margin: 0 0 70px;
      font-size: 48px;
      letter-spacing: 4px;
      font-weight: 500;
      color: #5a6675;
    }

    h1::after {
      content: "";
      display: block;
      width: 56px;
      height: 1px;
      background: rgba(200, 162, 168, 0.55);
      margin: 26px auto 0;
    }

    input[type="text"] {
      padding: 10px 14px;
      border-radius: 6px;
      border: 1px solid rgba(60, 60, 60, 0.18);
      width: 260px;
      background: rgba(255, 255, 255, 0.6);
      font-family: 'Cormorant Garamond', serif;
      font-size: 18px;
      outline: none;
      box-sizing: border-box;
    }

    input[type="text"]:focus {
      border-color: rgba(90, 102, 117, 0.55);
      box-shadow: 0 0 0 3px rgba(90, 102, 117, 0.10);
    }

    input[type="checkbox"] {
      width: auto;
      margin: 0;
    }

    button {
      padding: 7px 16px;
      border-radius: 6px;
      border: 1px solid rgba(90, 102, 117, 0.45);
      background: rgba(90, 102, 117, 0.08);
      color: #4f5a67;
      cursor: pointer;
      transition: all 0.25s ease;
      font-family: 'Cormorant Garamond', serif;
      letter-spacing: 1px;
      font-size: 15px;
      white-space: nowrap;
    }

    button:hover { background: rgba(90, 102, 117, 0.14); }

    .top-bar {
      display: flex;
      justify-content: center;
      gap: 14px;
      flex-wrap: wrap;
      margin-bottom: 20px;
      align-items: center;
    }

    #bookList {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(340px, 1fr));
      gap: 24px;
      margin-top: 40px;
    }

    .cover {
      width: 80px;
      height: 110px;
      object-fit: cover;
      border-radius: 8px;
      border: 1px solid rgba(60,60,60,0.10);
      background: rgba(255,255,255,0.6);
      flex: 0 0 auto;
      display: block;
    }

    .content {
      display: flex;
      flex-direction: column;
      gap: 10px;
      width: 100%;
      min-width: 0;
    }

    .title {
      font-weight: 600;
      font-size: 20px;
      letter-spacing: 0.5px;
      line-height: 1.2;
      word-break: break-word;
    }

    .seriesline {
      font-size: 14px;
      color: rgba(90,102,117,0.80);
      letter-spacing: 0.5px;
      font-style: italic;
      margin-top: -4px;
    }

    .controls {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 8px;
    }

    .checkset {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      user-select: none;
    }

    .mini-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 4px;
    }

    .mini-row button {
      padding: 4px 10px;
      font-size: 12px;
      letter-spacing: 0.5px;
    }

    /* Tags */
    .tags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 2px;
    }

    .tag {
      font-size: 12px;
      padding: 3px 10px;
      border-radius: 999px;
      background: rgba(200, 162, 168, 0.18);
      border: 1px solid rgba(200, 162, 168, 0.45);
      color: #5a6675;
      letter-spacing: 0.5px;
      cursor: pointer;
    }

    .tag.active {
      background: rgba(90, 102, 117, 0.20);
      border-color: rgba(90, 102, 117, 0.35);
    }

    /* Modal */
    .modal {
      position: fixed;
      inset: 0;
      background: rgba(20, 25, 35, 0.35);
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 28px;
      z-index: 9999;
    }

    .modal-card {
      width: min(520px, 92vw);
      background: rgba(255, 255, 255, 0.85);
      border: 1px solid rgba(60, 60, 60, 0.12);
      border-radius: 14px;
      box-shadow: 0 24px 70px rgba(0, 0, 0, 0.18);
      padding: 18px;
      backdrop-filter: blur(6px);
    }

    .modal-title {
      font-family: 'Playfair Display', serif;
      font-size: 18px;
      letter-spacing: 1px;
      color: #5a6675;
      margin: 6px 8px 14px;
    }

    .modal-img {
      width: 100%;
      height: auto;
      border-radius: 12px;
      border: 1px solid rgba(60, 60, 60, 0.10);
      display: block;
    }

    .modal-hint {
      margin: 12px 8px 6px;
      font-size: 14px;
      color: rgba(80, 90, 105, 0.75);
    }

    /* Flip card */
    .flip-card { perspective: 1200px; }
    .flip-inner {
      display: grid;
      transform-style: preserve-3d;
      transition: transform 0.55s ease;
    }
    .flip-card.flipped .flip-inner { transform: rotateY(180deg); }
    .flip-side {
      grid-area: 1 / 1;
      backface-visibility: hidden;
    }
    .flip-back { transform: rotateY(180deg); }

    /* Surface */
    .book-surface {
      background: rgba(255, 255, 255, 0.72);
      padding: 34px 36px;
      border-radius: 12px;
      border: 1px solid rgba(60, 60, 60, 0.10);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.04);
      display: flex;
      gap: 25px;
      align-items: flex-start;
      transition: box-shadow 0.25s ease;
      min-height: 320px;
    }
    
    .flip-card:hover .book-surface {
      box-shadow: 0 16px 40px rgba(0, 0, 0, 0.06);
    }

    .book-surface.finished {
      background: rgba(245, 238, 236, 0.75);
      border-left: 2px solid rgba(200, 162, 168, 0.75);
    }

    .side-badge {
      font-size: 12px;
      letter-spacing: 1px;
      color: rgba(90, 102, 117, 0.8);
      border: 1px solid rgba(90, 102, 117, 0.28);
      padding: 2px 10px;
      border-radius: 999px;
      display: inline-block;
      margin-bottom: 6px;
    }

    .note {
      font-size: 15px;
      color: rgba(70, 80, 95, 0.9);
      line-height: 1.5;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .note.empty { color: rgba(70, 80, 95, 0.45); }
  </style>
</head>

<body>
  <h1>The Reading Journal</h1>

  <div class="top-bar">
    <input
      type="text"
      id="titleInput"
      placeholder="Title"
      onkeydown="if(event.key === 'Enter') addBook()"
    />
    <button onclick="addBook()">Add</button>

    <input
      type="text"
      id="searchInput"
      placeholder="Search..."
      oninput="displayBooks()"
    />
  </div>

  <div id="bookList"></div>

  <input type="file" id="coverFileInput" accept="image/*" style="display:none" />

  <script>
    // ---------------------------
    // Books: localStorage
    // Covers: IndexedDB
    // ---------------------------
    let books = [];
    let activeTag = null;

    // ---- localStorage ----
    const savedBooks = localStorage.getItem("books");
    if (savedBooks) books = JSON.parse(savedBooks);

    function saveBooks() {
      localStorage.setItem("books", JSON.stringify(books));
    }

    function ensureBookIdsAndDefaults() {
      let changed = false;
      for (const b of books) {
        if (!b.id) {
          b.id = crypto.randomUUID
            ? crypto.randomUUID()
            : String(Date.now()) + Math.random().toString(16).slice(2);
          changed = true;
        }

        // series / volume
        if (typeof b.series !== "string") { b.series = ""; changed = true; }
        if (typeof b.volume !== "string") { b.volume = ""; changed = true; }

        // tags
        if (!Array.isArray(b.tags)) { b.tags = []; changed = true; }

        // B仕様
        if (typeof b.jpUrl !== "string") { b.jpUrl = ""; changed = true; }
        if (typeof b.trUrl !== "string") { b.trUrl = ""; changed = true; }
        if (typeof b.jpNote !== "string") { b.jpNote = ""; changed = true; }
        if (typeof b.trNote !== "string") { b.trNote = ""; changed = true; }

        // finished
        if (typeof b.finished !== "boolean") { b.finished = !!b.finished; changed = true; }
      }
      if (changed) saveBooks();
    }

    // ---- IndexedDB ----
    const DB_NAME = "reading_journal_db";
    const DB_VERSION = 1;
    const STORE = "covers";
    let db = null;

    function openDB() {
      return new Promise((resolve, reject) => {
        if (!("indexedDB" in window)) {
          reject(new Error("IndexedDB is not supported"));
          return;
        }
        const req = indexedDB.open(DB_NAME, DB_VERSION);

        req.onupgradeneeded = (event) => {
          const d = event.target.result;
          if (!d.objectStoreNames.contains(STORE)) d.createObjectStore(STORE);
        };
        req.onsuccess = () => { db = req.result; resolve(db); };
        req.onerror = () => reject(req.error);
      });
    }

    function putCover(key, blob) {
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE, "readwrite");
        tx.objectStore(STORE).put(blob, key);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    function getCover(key) {
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE, "readonly");
        const req = tx.objectStore(STORE).get(key);
        req.onsuccess = () => resolve(req.result || null);
        req.onerror = () => reject(req.error);
      });
    }

    function deleteCover(key) {
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE, "readwrite");
        tx.objectStore(STORE).delete(key);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    // ---- ObjectURL cache ----
    const coverUrlCache = new Map(); // key -> objectURL
    function revokeCoverUrl(key) {
      const url = coverUrlCache.get(key);
      if (url) {
        URL.revokeObjectURL(url);
        coverUrlCache.delete(key);
      }
    }

    function coverKey(bookId, side) {
      return `${bookId}:${side}`; // side "jp" | "tr"
    }

    // ---- UI helpers ----
    function createCheckSet(checkbox, text) {
      const wrapper = document.createElement("label");
      wrapper.className = "checkset";
      wrapper.appendChild(checkbox);
      wrapper.appendChild(document.createTextNode(text));
      return wrapper;
    }

    function openCoverModal({ title, src }) {
      const modal = document.createElement("div");
      modal.className = "modal";

      const card = document.createElement("div");
      card.className = "modal-card";

      const t = document.createElement("div");
      t.className = "modal-title";
      t.textContent = title || "Cover";

      const img = document.createElement("img");
      img.className = "modal-img";
      img.src = src;
      img.alt = "cover";

      const hint = document.createElement("div");
      hint.className = "modal-hint";
      hint.textContent = "Click outside or press Esc to close";

      card.appendChild(t);
      card.appendChild(img);
      card.appendChild(hint);
      modal.appendChild(card);
      document.body.appendChild(modal);

      function close() {
        document.removeEventListener("keydown", onKeyDown);
        modal.remove();
      }
      function onKeyDown(e) { if (e.key === "Escape") close(); }

      modal.addEventListener("click", (e) => { if (e.target === modal) close(); });
      document.addEventListener("keydown", onKeyDown);
    }

    // ---- App ----
    function addBook() {
      const input = document.getElementById("titleInput");
      const title = input.value.trim();
      if (!title) return;

      const id = crypto.randomUUID
        ? crypto.randomUUID()
        : String(Date.now()) + Math.random().toString(16).slice(2);

      books.push({
        id,
        title,
        finished: false,

        // side-specific
        jpUrl: "",
        trUrl: "",
        jpNote: "",
        trNote: "",

        // series
        series: "",
        volume: "",

        // shared
        tags: []
      });

      input.value = "";
      input.focus();
      saveBooks();
      displayBooks();
    }

    function numericOrNaN(v) {
      const n = Number(String(v).trim());
      return Number.isFinite(n) ? n : NaN;
    }

    async function displayBooks() {
      const list = document.getElementById("bookList");
      list.innerHTML = "";

      const searchText = (document.getElementById("searchInput")?.value || "")
        .toLowerCase()
        .trim();

      // Search: title OR series
      const filteredBooks = books.filter(b => {
        const hay = `${b.title || ""} ${b.series || ""}`.toLowerCase();
        const matchesSearch = hay.includes(searchText);
        const matchesTag = !activeTag || (Array.isArray(b.tags) && b.tags.includes(activeTag));
        return matchesSearch && matchesTag;
      });

      // Sort: unfinished -> finished, series -> volume -> title
      filteredBooks.sort((a, b) => {
        if (a.finished !== b.finished) return Number(a.finished) - Number(b.finished);

        const sa = (a.series || "").trim();
        const sb = (b.series || "").trim();
        if (sa !== sb) return sa.localeCompare(sb);

        const va = numericOrNaN(a.volume);
        const vb = numericOrNaN(b.volume);
        if (!Number.isNaN(va) && !Number.isNaN(vb) && va !== vb) return va - vb;

        const vaS = (a.volume || "").trim();
        const vbS = (b.volume || "").trim();
        if (vaS !== vbS) return vaS.localeCompare(vbS);

        return (a.title || "").localeCompare(b.title || "");
      });

      for (const book of filteredBooks) {
        const index = books.indexOf(book);

        // flip wrapper
        const flipCard = document.createElement("div");
        flipCard.className = "flip-card";

        const inner = document.createElement("div");
        inner.className = "flip-inner";

        const front = document.createElement("div"); // JP
        front.className = "flip-side book-surface";

        const back = document.createElement("div"); // EN
        back.className = "flip-side flip-back book-surface";

        if (book.finished) {
          front.classList.add("finished");
          back.classList.add("finished");
        }

        // click to flip
        flipCard.onclick = () => flipCard.classList.toggle("flipped");

        const buildSide = async ({ side, surface }) => {
          const isJP = side === "jp";
          const key = coverKey(book.id, side);

          // cover
          const img = document.createElement("img");
          img.className = "cover";
          img.alt = "cover";
          surface.appendChild(img);

          revokeCoverUrl(key);
          try {
            const blob = await getCover(key);
            if (blob) {
              const url = URL.createObjectURL(blob);
              coverUrlCache.set(key, url);
              img.src = url;

              img.style.cursor = "zoom-in";
              img.onclick = (e) => {
                e.stopPropagation();
                openCoverModal({ title: book.title, src: img.src });
              };
            } else {
              img.removeAttribute("src");
            }
          } catch {
            img.removeAttribute("src");
          }

          const content = document.createElement("div");
          content.className = "content";

          // title
          const titleEl = document.createElement("div");
          titleEl.className = "title";
          titleEl.textContent = book.title || "";
          if (book.finished) titleEl.style.textDecoration = "line-through";
          titleEl.style.cursor = "text";
          titleEl.title = "Double-click to edit";

          titleEl.ondblclick = (e) => {
            e.stopPropagation();

            const input = document.createElement("input");
            input.type = "text";
            input.value = book.title || "";
            input.style.width = "100%";
            input.style.height = "30px";
            input.style.fontSize = "20px";
            input.style.letterSpacing = "0.5px";
            input.style.padding = "6px 10px";
            input.style.borderRadius = "8px";
            input.style.border = "1px solid rgba(60,60,60,0.18)";
            input.style.background = "rgba(255,255,255,0.65)";

            const original = book.title || "";
            titleEl.replaceWith(input);
            input.focus();
            input.select();

            const commit = () => {
              const newTitle = input.value.trim();
              book.title = newTitle === "" ? original : newTitle;
              saveBooks();
              displayBooks();
            };
            const cancel = () => displayBooks();

            input.addEventListener("keydown", (ev) => {
              if (ev.key === "Enter") commit();
              if (ev.key === "Escape") cancel();
            });
            input.addEventListener("blur", commit);
          };

          // series line (titleの"下"に必ず出す)
          const seriesLine = document.createElement("div");
          seriesLine.className = "seriesline";
          if (book.series && book.series.trim()) {
            seriesLine.textContent = book.volume && book.volume.trim()
              ? `${book.series.trim()} — Vol.${book.volume.trim()}`
              : book.series.trim();
          } else {
            seriesLine.style.display = "none";
          }

          // side badge
          const sideLabel = document.createElement("div");
          sideLabel.className = "side-badge";
          sideLabel.textContent = isJP ? "Japanese" : "English";

          // tags
          const tagsEl = document.createElement("div");
          tagsEl.className = "tags";

          (book.tags || []).forEach(tag => {
            const tagEl = document.createElement("span");
            tagEl.className = "tag" + (tag === activeTag ? " active" : "");
            tagEl.textContent = tag;

            tagEl.onclick = (e) => {
              e.stopPropagation();
              activeTag = (activeTag === tag) ? null : tag;
              displayBooks();
            };

            // right-click delete (no confirm)
            tagEl.oncontextmenu = (e) => {
              e.preventDefault();
              e.stopPropagation();
              book.tags = (book.tags || []).filter(t => t !== tag);
              if (activeTag === tag) activeTag = null;
              saveBooks();
              displayBooks();
            };

            tagsEl.appendChild(tagEl);
          });

          // note
          const noteEl = document.createElement("div");
          noteEl.className = "note";
          const noteValue = isJP ? (book.jpNote || "") : (book.trNote || "");
          if (!noteValue) {
            noteEl.classList.add("empty");
            noteEl.textContent = "No notes yet.";
          } else {
            noteEl.textContent = noteValue;
          }

          noteEl.ondblclick = (e) => {
            e.stopPropagation();

            const textarea = document.createElement("textarea");
            textarea.value = noteValue;
            textarea.style.width = "100%";
            textarea.style.minHeight = "90px";
            textarea.style.resize = "vertical";
            textarea.style.fontFamily = "inherit";
            textarea.style.fontSize = "16px";
            textarea.style.padding = "10px 12px";
            textarea.style.borderRadius = "10px";
            textarea.style.border = "1px solid rgba(60,60,60,0.18)";
            textarea.style.background = "rgba(255,255,255,0.65)";
            textarea.style.boxSizing = "border-box";

            noteEl.replaceWith(textarea);
            textarea.focus();

            const commit = () => {
              const v = textarea.value.trim();
              if (isJP) book.jpNote = v;
              else book.trNote = v;
              saveBooks();
              displayBooks();
            };
            const cancel = () => displayBooks();

            textarea.addEventListener("keydown", (ev) => {
              if (ev.key === "Escape") cancel();
              if (ev.key === "Enter" && (ev.ctrlKey || ev.metaKey)) commit();
            });
            textarea.addEventListener("blur", commit);
          };

          // finished checkbox only
          const finishedCheckbox = document.createElement("input");
          finishedCheckbox.type = "checkbox";
          finishedCheckbox.checked = !!book.finished;
          finishedCheckbox.onchange = (e) => {
            e.stopPropagation();
            book.finished = finishedCheckbox.checked;
            saveBooks();
            displayBooks();
          };

          const controls = document.createElement("div");
          controls.className = "controls";
          controls.onclick = (e) => e.stopPropagation();

          controls.appendChild(sideLabel);
          controls.appendChild(createCheckSet(finishedCheckbox, "Finished"));

          // buttons
          const miniRow = document.createElement("div");
          miniRow.className = "mini-row";
          miniRow.onclick = (e) => e.stopPropagation();

          const removeButton = document.createElement("button");
          removeButton.textContent = "Remove";
          removeButton.onclick = async (e) => {
            e.stopPropagation();
            try { await deleteCover(coverKey(book.id, "jp")); } catch {}
            try { await deleteCover(coverKey(book.id, "tr")); } catch {}
            revokeCoverUrl(coverKey(book.id, "jp"));
            revokeCoverUrl(coverKey(book.id, "tr"));

            books.splice(index, 1);
            saveBooks();
            displayBooks();
          };

          const urlButton = document.createElement("button");
          const urlValue = isJP ? (book.jpUrl || "") : (book.trUrl || "");
          urlButton.textContent = urlValue ? "Open URL" : "Set URL";
          urlButton.onclick = (e) => {
            e.stopPropagation();
            if (!urlValue) {
              const url = prompt("Enter URL");
              if (url) {
                if (isJP) book.jpUrl = url;
                else book.trUrl = url;
                saveBooks();
                displayBooks();
              }
            } else {
              window.open(urlValue, "_blank");
            }
          };

          const coverButton = document.createElement("button");
          coverButton.textContent = "Set Cover";
          coverButton.onclick = (e) => {
            e.stopPropagation();
            const fileInput = document.getElementById("coverFileInput");
            fileInput.onchange = async () => {
              const file = fileInput.files?.[0];
              if (!file) return;

              try {
                await putCover(key, file);
                revokeCoverUrl(key);
                displayBooks();
              } catch {
                alert("表紙の保存に失敗しました（IndexedDBエラー）。");
              } finally {
                fileInput.value = "";
              }
            };
            fileInput.click();
          };

          const clearCoverButton = document.createElement("button");
          clearCoverButton.textContent = "Clear Cover";
          clearCoverButton.onclick = async (e) => {
            e.stopPropagation();
            try {
              await deleteCover(key);
              revokeCoverUrl(key);
              displayBooks();
            } catch {
              alert("表紙の削除に失敗しました。");
            }
          };

          const tagButton = document.createElement("button");
          tagButton.textContent = "Add Tag";
          tagButton.onclick = (e) => {
            e.stopPropagation();
            const tag = prompt("Enter tag");
            if (!tag) return;
            const clean = tag.trim();
            if (!clean) return;
            if (!Array.isArray(book.tags)) book.tags = [];
            if (!book.tags.includes(clean)) {
              book.tags.push(clean);
              saveBooks();
              displayBooks();
            }
          };

          const seriesButton = document.createElement("button");
          seriesButton.textContent = book.series ? "Edit Series" : "Set Series";
          seriesButton.onclick = (e) => {
            e.stopPropagation();

            const name = prompt("Series name", book.series || "");
            if (name === null) return;

            const vol = prompt("Volume number", book.volume || "");
            if (vol === null) return;

            book.series = name.trim();
            book.volume = vol.trim();
            saveBooks();
            displayBooks();
          };

          miniRow.appendChild(removeButton);
          miniRow.appendChild(urlButton);
          miniRow.appendChild(coverButton);
          miniRow.appendChild(clearCoverButton);
          miniRow.appendChild(tagButton);
          miniRow.appendChild(seriesButton);

          // assemble (順番が超大事)
          content.appendChild(titleEl);
          content.appendChild(seriesLine);
          content.appendChild(tagsEl);
          content.appendChild(controls);
          content.appendChild(noteEl);
          content.appendChild(miniRow);

          surface.appendChild(content);
        };

        await buildSide({ side: "jp", surface: front });
        await buildSide({ side: "tr", surface: back });

        inner.appendChild(front);
        inner.appendChild(back);
        flipCard.appendChild(inner);
        list.appendChild(flipCard);
      }
    }

    // ---- Init ----
    (async function init() {
      ensureBookIdsAndDefaults();
      try {
        await openDB();
      } catch (e) {
        alert("IndexedDBが使えない環境です。表紙の保存はできません。");
      }
      displayBooks();
    })();

    window.addEventListener("beforeunload", () => {
      for (const [key] of coverUrlCache) revokeCoverUrl(key);
    });
  </script>
</body>
</html>